#! /usr/bin/env stack
{-
   stack --resolver lts-10.1 --install-ghc runghc --package text
-}

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE NamedFieldPuns #-}

import qualified Data.Char as C
import qualified Data.List as L
import qualified Data.Map.Strict as M
import qualified Data.Text as T
import qualified Data.Text.IO as TIO

data Room = Room
  { name :: T.Text
  , sector :: Int
  , checksum :: T.Text
  } deriving Show

readRooms :: T.Text -> [Room]
readRooms input = map mkRoom $ T.lines input
  where
    mkRoom line =
      let chunks = T.splitOn "-" line
          [s, c] = T.splitOn "[" $ T.dropEnd 1 $ last chunks
       in Room { name = T.concat $ L.init chunks, sector = read (T.unpack s), checksum = c }

mkCounter name = T.foldl' (\m c -> M.alter (\r -> case r of
                                               Nothing -> Just 1
                                               Just v -> Just $ v + 1
                                      ) c m) M.empty name

mkChecksum counter = T.pack $ L.take 5 $ L.map fst $ L.sortOn (\(c, v) -> (1 / v, c)) $ M.toList counter

isValid :: Room -> Bool
isValid Room{ name, checksum } = checksum == mkChecksum (mkCounter name)

solve1 :: [Room] -> Int
solve1 = L.sum . L.map sector . L.filter isValid

solve2 :: [Room] -> [Room]
solve2 = L.map decrypt . L.filter isValid
  where
    decrypt r@Room{ name, sector } = r{ name = T.map (\c -> C.chr $ ((C.ord c) - (C.ord 'a') + sector) `mod` 26 + (C.ord 'a')) name }

main :: IO ()
main = TIO.interact (T.pack . show . solve2 . readRooms)
