1:1-1:1::Main.$trModule :: "GHC.Types.Module"
19:14-19:18::Main.$fShowRoom :: "(GHC.Show.Show Main.Room)"
22:1-22:10::Main.readRooms :: "Data.Text.Internal.Text -> [Main.Room]"
22:11-22:16::input :: "Data.Text.Internal.Text"
22:19-22:29::lq_anf$##7205759403792809792 :: "x1:[Data.Text.Internal.Text] -> {v : [Main.Room] | len v == len x1}"
22:32-22:39::_ :: "{v : Data.Text.Internal.Text -> [Data.Text.Internal.Text] | v == Data.Text.lines}"
24:5-24:11::mkRoom :: "Data.Text.Internal.Text -> Main.Room"
24:12-24:16::line :: "Data.Text.Internal.Text"
25:11-25:17::chunks :: "[Data.Text.Internal.Text]"
25:20-25:29::_ :: "{v : Data.Text.Internal.Text -> Data.Text.Internal.Text -> [Data.Text.Internal.Text] | v == Data.Text.splitOn}"
26:20-26:29::_ :: "{v : Data.Text.Internal.Text -> Data.Text.Internal.Text -> [Data.Text.Internal.Text] | v == Data.Text.splitOn}"
26:36-26:45::_ :: "{v : GHC.Types.Int -> Data.Text.Internal.Text -> Data.Text.Internal.Text | v == Data.Text.dropEnd}"
26:50-26:61::lq_anf$##7205759403792809777 :: "Data.Text.Internal.Text"
27:25-27:49::lq_anf$##7205759403792809787 :: "Data.Text.Internal.Text"
27:36-27:49::lq_anf$##7205759403792809786 :: "{v : [Data.Text.Internal.Text] | len v == len chunks - 1}"
27:60-27:64::_ :: "[GHC.Types.Char] -> GHC.Types.Int"
27:66-27:74::_ :: "{v : Data.Text.Internal.Text -> [GHC.Types.Char] | v == Data.Text.Show.unpack}"
29:1-29:10::Main.mkCounter :: "(GHC.Num.Num a) =>\nData.Text.Internal.Text -> (Data.Map.Internal.Map GHC.Types.Char a)"
29:11-29:15::name :: "Data.Text.Internal.Text"
29:29-29:30::m :: "(Data.Map.Internal.Map GHC.Types.Char a)"
29:31-29:32::c :: "GHC.Types.Char"
29:36-29:43::_ :: "((GHC.Base.Maybe a) -> (GHC.Base.Maybe a)) -> GHC.Types.Char -> (Data.Map.Internal.Map GHC.Types.Char a) -> (Data.Map.Internal.Map GHC.Types.Char a)"
29:46-29:47::r :: "(GHC.Base.Maybe a)"
30:59-30:65::lq_anf$##7205759403792809796 :: "a"
31:58-31:70::lq_anf$##7205759403792809797 :: "x1:a -> {v : (GHC.Base.Maybe a) | fromJust v == x1\n                                  && (isJust v <=> true)}"
31:65-31:70::lq_anf$##7205759403792809800 :: "a"
31:67-31:68::_ :: "x1:a -> x2:a -> {VV : a | VV == x1 + x2}"
34:1-34:11::Main.mkChecksum :: "(GHC.Real.Fractional a, GHC.Classes.Ord a) =>\n(Data.Map.Internal.Map GHC.Types.Char a) -> Data.Text.Internal.Text"
34:12-34:19::counter :: "(Data.Map.Internal.Map GHC.Types.Char a)"
34:22-34:105::Data.Text.pack :: "{v : [GHC.Types.Char] -> Data.Text.Internal.Text | v == Data.Text.pack}"
34:31-34:39::lq_anf$##7205759403792809805 :: "[GHC.Types.Char] -> [GHC.Types.Char]"
34:42-34:51::lq_anf$##7205759403792809807 :: "x1:[(GHC.Types.Char, a)] -> {v : [GHC.Types.Char] | len v == len x1}"
34:54-34:62::_ :: "((GHC.Types.Char, a) -> (a, GHC.Types.Char)) -> [(GHC.Types.Char, a)] -> [(GHC.Types.Char, a)]"
34:64-34:85::lq_anf$##7205759403792809808 :: "(GHC.Types.Char, a)"
34:76-34:81::lq_anf$##7205759403792809811 :: "a"
34:78-34:79::_ :: "x1:a -> x2:{VV : a | VV /= 0} -> {VV : a | VV == x1 / x2}"
34:89-34:105::lq_anf$##7205759403792809814 :: "[(GHC.Types.Char, a)]"
37:1-37:8::Main.isValid :: "Main.Room -> GHC.Types.Bool"
37:34-37:73::ds_d4aZ :: "Data.Text.Internal.Text"
37:43-37:45::_ :: "x1:Data.Text.Internal.Text -> x2:Data.Text.Internal.Text -> {v : GHC.Types.Bool | v <=> x1 == x2}"
37:46-37:56::_ :: "(Data.Map.Internal.Map GHC.Types.Char GHC.Types.Double) -> Data.Text.Internal.Text"
37:58-37:67::_ :: "Data.Text.Internal.Text -> (Data.Map.Internal.Map GHC.Types.Char GHC.Types.Double)"
40:1-40:7::Main.solve1 :: "[Main.Room] -> GHC.Types.Int"
40:10-40:49::lq_anf$##7205759403792809834 :: "[GHC.Types.Int] -> GHC.Types.Int"
40:18-40:30::lq_anf$##7205759403792809835 :: "x1:[Main.Room] -> {v : [GHC.Types.Int] | len v == len x1}"
40:33-40:49::lq_anf$##7205759403792809836 :: "x1:[Main.Room] -> {v : [Main.Room] | len v <= len x1}"
43:1-43:7::Main.solve2 :: "[Main.Room] -> [Main.Room]"
43:10-43:23::lq_anf$##7205759403792809851 :: "x1:[Main.Room] -> {v : [Main.Room] | len v == len x1}"
43:26-43:42::lq_anf$##7205759403792809852 :: "x1:[Main.Room] -> {v : [Main.Room] | len v <= len x1}"
45:5-45:12::decrypt :: "Main.Room -> Main.Room"
45:13-45:14::r :: "Main.Room"
45:38-45:134::lq_anf$##7205759403792809850 :: "{v : Main.Room | v == r}"
45:48-45:53::_ :: "{v : (GHC.Types.Char -> GHC.Types.Char) -> Data.Text.Internal.Text -> Data.Text.Internal.Text | v == Data.Text.map}"
45:56-45:57::c :: "GHC.Types.Char"
45:61-45:126::GHC.Char.chr :: "{v : GHC.Types.Int -> GHC.Types.Char | v == GHC.Char.chr}"
45:69-45:112::lq_anf$##7205759403792809845 :: "GHC.Types.Int"
45:70-45:93::lq_anf$##7205759403792809842 :: "GHC.Types.Int"
45:71-45:76::_ :: "{v : GHC.Types.Char -> GHC.Types.Int | v == GHC.Base.ord}"
45:80-45:81::_ :: "x1:GHC.Types.Int -> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 - x2}"
45:83-45:88::_ :: "{v : GHC.Types.Char -> GHC.Types.Int | v == GHC.Base.ord}"
45:94-45:95::_ :: "x1:GHC.Types.Int -> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 + x2}"
45:104-45:109::_ :: "x1:GHC.Types.Int -> x2:{v : GHC.Types.Int | v /= 0} -> {v : GHC.Types.Int | v == x1 mod x2\n                                                                            && (0 <= x1\n                                                                                && 0 < x2 => 0 <= v\n                                                                                             && v < x2)}"
45:113-45:114::_ :: "x1:GHC.Types.Int -> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 + x2}"
45:116-45:121::_ :: "{v : GHC.Types.Char -> GHC.Types.Int | v == GHC.Base.ord}"
48:1-48:5:::Main.main :: "(GHC.Types.IO ())"
48:8-48:20::_ :: "{v : (Data.Text.Internal.Text -> Data.Text.Internal.Text) -> (GHC.Types.IO ()) | v == Data.Text.IO.interact}"
48:22-48:56::lq_anf$##7205759403792809856 :: "Data.Text.Internal.Text -> Data.Text.Internal.Text"
48:31-48:56::lq_anf$##7205759403792809855 :: "Data.Text.Internal.Text -> [GHC.Types.Char]"
48:38-48:56::lq_anf$##7205759403792809854 :: "Data.Text.Internal.Text -> [Main.Room]"